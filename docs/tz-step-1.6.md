# ТЗ шага 1.6 — интеграция MOEX ISS в `market‑data‑service`

## 1. Контекст и мотивация

После выполнения шага 1.5 в репозитории появился сервис `market‑data‑service`, который пока представляет собой пустую заглушку. Он проверяет JWT‑токен и отдаёт лишь тестовый ответ. Все сценарии взаимодействия с пользователем реализованы в `logic‑commands‑center` — BFF‑слое для Telegram‑бота. Такой подход удобен для консоли, но мешает развитию: скоро появятся **web‑интерфейс** и **Telegram mini‑apps**, а в перспективе — переход на **Kafka** и отказ от тесной привязки к одному оркестратору. 

Основная цель шага 1.6 — превратить `market‑data‑service` из заглушки в самостоятельный микросервис, который:

* **Получает рыночные данные** с внешнего источника (MOEX ISS API);
* **Предоставляет общий REST‑интерфейс**, годный для любого клиента (консольного бота, веб‑страницы, мобильно‑го mini‑app);
* **Сохраняет независимость** от `logic‑commands‑center` и готовится к будущему переходу на Kafka.

## 2. Требования к архитектуре

### 2.1 Самостоятельность сервиса

Сервис `market‑data` должен быть **самодостаточным доменным сервисом**, выполняющим только одну роль — поставщик рыночных данных. Он:

1. **Не знает о Telegram, консольных командах и внутренних сценариях**. `logic‑commands‑center` остаётся BFF‑слоем для чата, который преобразует команды в HTTP‑запросы. В будущем аналогичным BFF будет web‑слой (mini‑app). 
2. **Публикует собственный API**. Клиенты получают данные через стандартные REST‑эндпоинты `/api/market/v1/...`, описывающие бизнес‑операции (получить инструменты, свечи, стакан, сделки). 
3. **Внутренне разделён на ядро и адаптеры**: есть слой use‑cases (`MarketDataUseCase`) и транспортные адаптеры. В шаге 1.6 реализуется только HTTP‑адаптер (REST‑контроллер); в будущем добавится Kafka‑consumer, который будет вызывать те же use‑cases, не затрагивая бизнес‑логику.

### 2.2 Версионированный REST‑API

Сервис должен реализовать версионированный API `/api/market/v1/…`, который можно масштабировать и менять независимо. Эндпоинты организованы по ресурсам и параметрам, не содержат Telegram‑специфики и подходят для любого front‑end клиента:

| Метод и путь | Назначение | Параметры |
| --- | --- | --- |
| **`GET /api/market/v1/instruments`** | Получить список доступных инструментов (акций) на заданной доске. | `engine` (строка, по умолчанию `stock`), `market` (по умолчанию `shares`), `board` (по умолчанию `TQBR`), `filter` (поиск по тикеру/названию), `limit`/`offset` для пагинации. |
| **`GET /api/market/v1/quotes`** | Получить актуальные котировки по инструменту. | `sec` (тикер), `board` (доска, напр. `TQBR`). Возвращаются поля последней цены, изменения, объёма и времени торгов. |
| **`GET /api/market/v1/candles`** | Получить свечи (OHLCV) по инструменту за период. | `sec`, `board`, `interval` (1, 10, 60, 1440 — минута, 10 мин, час, день), `from`, `till` в формате `YYYY-MM-DD` или ISO‑8601. Дата `from` интерпретируется как `00:00:00`, `till` — как `23:59:59`. |
| **`GET /api/market/v1/orderbook`** | Получить стакан котировок. | `sec`, `board`, `depth` (срез книги; так как ISS не принимает параметр `depth`, обрезка выполняется локально). Возвращается список лучших заявок. |
| **`GET /api/market/v1/trades`** | Получить сделки по инструменту. | `sec`, `board`, `from` (номер сделки или момент времени), `limit` (1, 10, 100, 1000 или 5000) — допустимые значения для ISS【762903122229017†L144-L161】. |

Версия API (`v1`) фиксируется в URL; при изменениях (например, добавление новых параметров или изменение форматов) будет выпущена новая версия (`v2`) без поломки существующих клиентов.

### 2.3 Интеграция с MOEX ISS

Для получения данных сервис обращается к официальному ISS API Московской биржи. Все основные операции реализуются через следующие эндпоинты (JSON‑формат):

* **Список инструментов** — `/engines/stock/markets/shares/boards/TQBR/securities.json`. Возвращает данные по бумагам режима `TQBR`: тикер, название, лот, объём, цена закрытия, обороты и др【762903122229017†L146-L161】.
* **Данные по одной бумаге** — `/engines/stock/markets/shares/boards/TQBR/securities/{sec}.json`【762903122229017†L146-L161】.
* **Свечи** — `/engines/stock/markets/shares/boards/TQBR/securities/{sec}/candles.json` (поддерживает параметры `from`, `till`, `interval`)【762903122229017†L164-L179】.
* **Стакан** — `/engines/stock/markets/shares/boards/TQBR/securities/{sec}/orderbook.json`【762903122229017†L158-L161】.
* **Сделки** — `/engines/stock/markets/shares/boards/TQBR/securities/{sec}/trades.json`【762903122229017†L153-L161】.

ISS возвращает данные в виде набора “блоков” (sections). Каждому блоку соответствует список колонок (`columns`) и двумерный массив `data`. Важно правильно сопоставлять индекс колонки полю модели и использовать параметры `iss.only` и `<block>.columns` для получения только нужных секций — это ускоряет ответы и упрощает парсинг.

### 2.4 Безопасность и доступ

* Все публичные эндпоинты защищены RBAC. Для чтения рыночных данных нужен JWT‑токен с пермишеном `PERM_MARKETDATA_READ`. `PERM_MARKETDATA_ADMIN` оставляем на будущее и в этом шаге не вводим.
* В шаге 1.6 сервис сам валидирует JWT как resource‑server и принимает запросы напрямую. `api‑gateway` остаётся сервисом идентификации/аутентификации и не проксирует API.

### 2.5 Приготовления к Kafka (без реализации)

В рамках шага 1.6 Kafka не внедряется, но проектирование должно учесть будущий переход:

1. **Выделенный слой use‑cases**. Все бизнес‑функции (получить инструменты, котировки, свечи, стакан, сделки) помещаются в класс/интерфейс `MarketDataUseCase`. REST‑контроллер вызывает его методы. В будущем Kafka‑consumer будет вызывать эти же методы.
2. **Корреляция запросов**. Все DTO, возвращаемые сервисом (например, `CandleResponse`), могут содержать поле `correlationId`, которое клиент может передавать в Kafka‑сообщениях. Сейчас это поле опционально, но закладывается в модели на будущее.
3. **Потенциальные топики**: `marketdata.requests` (запросы), `marketdata.responses` (ответы), `marketdata.errors` (ошибки). Политика ретраев и dead‑letter queue описывается в документации, но не реализуется.

## 3. План реализации

### 3.1 Создание структуры проекта

1. **Пакеты**:
   - `com.logicsignalprotector.marketdata.client` — класс `MoexClient`, который формирует запросы к ISS, добавляет параметры (`iss.only`, `<block>.columns`), выполняет HTTP‑вызовы (WebClient) и парсит ответ в DTO. Для ускорения повторных запросов можно внедрить Caffeine‑кэш (TTL 30–60 сек).
   - `com.logicsignalprotector.marketdata.dto` — модели: `InstrumentDto`, `QuoteDto`, `CandleDto`, `OrderBookDto`, `OrderBookEntryDto`, `TradeDto`, а также обёртки ответов (`InstrumentsResponse`, `CandlesResponse`, и т. д.). DTO отражают поля ISS, даты хранятся как `OffsetDateTime`.
   - `com.logicsignalprotector.marketdata.usecase` — интерфейс/класс `MarketDataUseCase` с методами `getInstruments`, `getQuotes`, `getCandles`, `getOrderBook`, `getTrades`. Внутри вызываются методы `MoexClient` и выполняется минимальная агрегация (например, обрезка глубины стакана).
   - `com.logicsignalprotector.marketdata.api` — REST‑контроллеры `InstrumentsController`, `QuotesController`, `CandlesController`, `OrderBookController`, `TradesController`. Контроллеры валидируют параметры запроса (например, допустимые интервал/лимит), вызывают use‑case, возвращают DTO и маппят исключения на соответствующие HTTP‑коды.

2. **Конфигурация**:
   - В `pom.xml` добавить зависимости `spring-boot-starter-webflux` (для WebClient), `spring-boot-starter-validation` (для валидации параметров) и `com.github.ben-manes.caffeine:caffeine` (кэш).
   - В `application.yml` создать раздел:
     ```yaml
     market:
       moex:
         base-url: https://iss.moex.com/iss
         timeout: 5s
         cache-ttl: 30s
     ```
     Параметры выводятся в `.env.example` для настройки разных окружений.
   - Настроить логирование уровня `INFO` для клиента, уровень `ERROR` для обработчика исключений.

3. **Безопасность**: добавить аннотацию `@PreAuthorize("hasAuthority('PERM_MARKETDATA_READ')")` на контроллеры. Миграции gateway не трогаем — используем уже существующий `MARKETDATA_READ`.

4. **Документация**: настроить OpenAPI/Swagger с описанием эндпоинтов, параметров, моделей и примеров. Включить в README сервиса раздел “API Reference”.

### 3.2 Изменения в других сервисах

**`logic‑commands‑center`** — как BFF‑слой для чата:

1. Обновить команду `/market` так, чтобы она работала через подкоманды (`instruments`, `quote`, `candles`, `orderbook`, `trades`), принимала параметры через `key=value` (например `limit=10`, `from=...`) и вызывала соответствующий HTTP‑эндпоинт `market‑data`. 
2. Ответы сервиса преобразовывать в текстовые таблицы (для Telegram) или в карточки (для mini app), **не модифицируя API `market‑data`**. Соответственно, разные интерфейсы (консоль, web, mini‑app) будут жить в своих адаптерах.

**`api-gateway`**: изменений нет — прокси `/api/market/**` не добавляется, `PERM_MARKETDATA_ADMIN` не создаётся.

### 3.3 Тестирование и CI

1. **Юнит‑тесты**: тестировать клиента ISS на корректный разбор блоков, на выброс исключений при ошибках сети и невалидных ответах.
2. **Интеграционные тесты**: с помощью WireMock (или MockWebServer) эмулировать ответы MOEX и тестировать полную цепочку `controller → use‑case → client`. Проверить валидацию входных параметров, кеширование, обработку лимитов, интервалов и глубины.
3. **E2E‑тесты**: протестировать связку `logic‑commands‑center + market‑data-service` в docker‑compose (можно написать сценарии для команды `/market` и сравнить текстовые ответы).
4. **CI/CD**: обновить GitHub Actions — запускать тесты сервиса, собирать Docker‑образ и пушить его в registry. PR должен включать отчёт о реализации и обновлённые диаграммы.

## 4. Итоговый результат

После завершения шага 1.6 `market‑data-service` превратится в полноценный модуль доменной логики. Он будет предоставлять **универсальный, версионированный REST‑API** для получения рыночных данных. Все клиенты (консольный бот, web‑front, mini‑app) будут обращаться к одному API напрямую, передавая ????? ???????. Внутренняя архитектура сервиса (use‑cases + адаптеры) позволит в будущем добавить **Kafka‑взаимодействие** без переписывания логики. За счёт слабой связности сервисы смогут развиваться независимо: `logic` останется BFF для интерфейса, `market‑data` — поставщик данных, `api‑gateway` — слой идентификации/аутентификации. ТЗ описывает не только API и модели, но и порядок разработки, конфигурацию, тестирование и подготовку к масштабированию.
